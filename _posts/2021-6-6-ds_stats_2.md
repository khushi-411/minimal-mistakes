---
published: true
title: Exploratory Statistical Analysis
collection: ds
layout: single
author_profile: true
read_time: true
categories: [datascience]
excerpt : "datascience"
header :
    overlay_image: "https://khushi-411.github.io/assets/images/stat-data-analysis.png"
    teaser: "https://khushi-411.github.io/assets/images/stat-data-analysis.png"
comments : true
toc: true
toc_sticky: true
sidebar:
    nav: sidebar-sample
---

{% highlight python %}
{% endhighlight %}

<script type="text/javascript" async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

## **Exploratory Statistical Analysis**

The process of analysing data so as to take out some important characteristics from it, is known as **exploratory data analysis**. Performing data analysis through statistical methods like `mode`, `probability`, `expected value`, `correlation` etc is known as **exploratory statistical analysis.**

### **Exploring Binary and Categorical Data**

**Binary Data:** Data which can take only two possible values, 0 or 1.

**Categorical Data:** Data which has been divided into categories or groups according to their features.

#### **Mode**

* `Mode` is the value that appear most offten in dataset.
* It is a summay statistic for **categorical data** i.e. grouped data or set of values representing a possible categories.
* It is not used for **numeric data** i.e. data expressed in number scale.

The function to calculate model:

```
def find_mode(counts, n):

  """Finds model of sample.

  This function consists of two method to calculate:
  * without library function
  * via library function

  Parameters
  ----------
  counts : list
           number of entries each emotion type has

  n : str
      select method to calucate iqr range

  Example
  -------
  >>> for n = 0, Time taken to calculate:  0.0002598762512207031, Mode of sample:  [3, 8989]

  Results
  -------
  mode : list
         returns emotion type along with its number of values

"""

  try:

    n = int(n)

    print("Shape of selected numpy array: ", counts.shape)
    print("Data type of _data_numpy: ", type(counts))

    if n is 0:

      start = time.time()
      max = counts[0]
      num = 0
      for row in counts:
        num +=1
        if row > max:
          mode = num-1
          max = row

      list = [mode, max]

      print("Time taken to calculate: ", time.time() - start)
      return list

    if n is 1:
   
      start = time.time()
      mode = counts.mode(dropna=True)
      print("Time taken to calculate: ", time.time() - start)
      return mode

    if n is not 0 or n is not 1:
      print("Enter correct value")
  
  except StatisticsError as error:
    raise error
  
  except Exception as error:
    print(error)
    raise error
```

Function Call:

```
n = input("Enter 0 (To find mode without any library function), Enter 1 (Via using Library Function): ")
mode = find_mode(counts, n)
print("Mode of sample: ", mode)
```

#### **Probability**

* `Probability` of an event will happen is how likly the event occurs again and again if tested again and again.
* **Formula:**

$$ \begin{equation} \textrm{Probability} = \frac{Number of Favourable Outcomes}{Total Number of Favourable Outcomes}  \end{equation} $$

The function to calculate probability:

```
def find_prob(counts):
  
  """To find probability of emotion type to be predicted.

  Parameters
  ----------
  counts : list
           number of entries each emotion type has

  Example
  -------
  >>> Time taken to calculate:  2.6702880859375e-05, Probability of each emotion type:  [0.13801655195474685, 0.01524228829381113, 0.14269791289324826, 0.25048067545350683, 0.1693370858528158, 0.11151670521358709, 0.17270878033828405]
  """

  try:

    print("Shape of selected numpy array: ", counts.shape)
    print("Data type of _data_numpy: ", type(counts))

    start = time.time()
    sum = 0
    for row in counts:
      sum += row
    probability = []
    for row in counts:
      p = row/sum
      probability.append(p)
    print("Time taken to calculate: ", time.time() - start)
    return probability
  
  except StatisticsError as error:
    raise error
  
  except Exception as error:
    print(error)
    raise error
    
```

Function Call:

```
prob = find_prob(counts)
print("Probability of each emotion type: ", prob)
```

#### **Expected Value**


