---
published: true
title: Descriptive Statistical Analysis
collection: ds
layout: single
author_profile: true
read_time: true
categories: [Data Science]
excerpt : "Data Science"
header :
    overlay_image: "https://khushi-411.github.io/assets/images/stat-data-analysis.png"
    teaser: "https://khushi-411.github.io/assets/images/stat-data-analysis.png"
comments : true
toc: true
toc_sticky: true
sidebar:
    nav: sidebar-sample
---

{% highlight python %}
{% endhighlight %}

<script type="text/javascript" async
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

## **Descriptive Statistical Analysis**


This statistical data analysis methods is used when we want to know about the features of data i.e what all things are present in the distribution

### **Estimates Of Location**

* To find the value that best describes the data.
* Helps to estimate location parameter for the distribution.

#### **Mean**

* `Mean` is sum of values divided by total number of values.
* It is also known as `Average`.

**Formula:**

To compute the mean for a set of $$ n $$ values $$ x_1, x_2, ..., x_n $$ is:

$$ \begin{equation} \textrm{Mean} = \bar{x} = \frac{\sum ^n_{i=1} x_i}{n} \tag{i} \end{equation} $$

Here, $$\bar{x}$$ : Represents mean of a sample from population.

The function to calculate mean:

```
def find_mean(_data_numpy, n):

  """Finds mean of sample.

  This method calculates mean in three different ways:
  * without using library function
  * using numpy np.sum() function
  * via direct library function

  Parameters
  ----------
  _data_numpy : ndarray 
                All the pixel data of selected emotion

  n : str
      user difined, how to calculate mean

  Example
  -------
  >>> for _emotion_type = 3 (happiness)
  >>> n = 0, Time taken to calculate:  10.261376142501831, Mean of sample:  129.08117932140826
  >>> n = 1, Time taken to calculate:  0.021773815155029297, Mean of sample:  129.08117932140826
  >>> n = 2, Time taken to calculate:  0.030038833618164062, Mean of sample:  129.08117932140826

  Results
  -------
  mean : float
        mean of sample
  
  """

  try:

    print("Shape of selected numpy array: ", _data_numpy.shape)

    n = int(n)

    if n is 0:
      start = time.time()
      sum = 0
      for i in range(_data_numpy.shape[0]):
        for j in range(_data_numpy.shape[1]):
          sum += _data_numpy[i][j]
      mean = float(sum/(_data_numpy.shape[0]*_data_numpy.shape[1]))
      print("Time taken to calculate: ", time.time() - start)
      return mean

    elif n is 1:
      start = time.time()
      sum = np.sum(_data_numpy)
      mean = float(sum/(_data_numpy.shape[0]*_data_numpy.shape[1]))
      print("Time taken to calculate: ", time.time() - start)
      return mean

    elif n is 2:
      start = time.time()
      mean = _data_numpy.mean()
      print("Time taken to calculate: ", time.time() - start)
      return mean
    
    if n is not 0 or n is not 1 or n is not 2:
      print("Enter correct value")

  except StatisticsError as error:
    raise error
    
  except Exception as error:
    print(error)
    raise error

```

To use the function:

```
n = input("Enter 0 (To find mean without any library function), Enter 1 (To find via using np.sum()), Enter 2 (Via using Library Function): ")
print("Data Type of taken input: ", type(n))

_emotion_type = input("Enter the emotion type whose mean of pixel values you want to find: ")
print("Data Type of _emotion_type: ", type(_emotion_type))

_data, _data_numpy, _data_label, _data_label_numpy = select_emotion(df_all, df_label, df, _emotion_type)

mean = find_mean(_data_numpy, n)
print(type(mean))
print("Mean of sample: ", mean)
```

#### **Trimmed Mean**

* `Trimmed Mean` is the average of all values after dropping fixed number of extreme values (sorted values).
* Also known as `Truncated Mean`.
* Widely used to avoid the influence of outliers.
* It is a trade-off between the median and the mean.

**Formula:**

Here, $$x_1 , x_2 , ..., x_n$$ represents the sorted values, where $$x_1$$ is the smallest and $$x_n$$ is the largest value.

$$ \begin{equation} \textrm{Trimmed Mean} = \bar{x} = \frac{\sum ^{n-p}_{i=p+1} x_{(i)}}{n-2p} \tag{ii} \end{equation} $$

> <font color = "green"> <b> <i> Note: </i> </b></font> `2p` represent the omitted smallest and largest values.

The function to calculate `Trimmed Mean`:

```
def find_trimmed_mean(_data_numpy, n, p):

  """To find the trimmed mean of the sample.

  This method finds trimmed mean using two ways.
  * without using library function
  * using library function

  Parameters
  ----------
  _data_numpy : ndarray
                numpy array of selected sample

  n : str
      select type of method to calucate trimmed mean

  p : str
      fraction of sample we want to omit from both side

  Example
  -------
  >>> for _emotion_type = 3, p = 0.05
  >>> n = 0, Time taken to calculate:  0.13057208061218262, Trimmed Mean of sample:  129.47220185935402
  >>> n = 1, Time taken to calculate:  0.1196749210357666, Trimmed Mean of sample:  129.47220185935402

  Results
  -------
  trimmed_mean : float
                 trimmed mean of sample

  Note
  ----
  This function 1st sorts the numpy array, then calculate

  """

  try:

    print("Shape of selected numpy array: ", _data_numpy.shape)

    n = int(n)
    p = float(p)
    _data_numpy = np.asarray(_data_numpy)
    start_time = time.time()
    _data_numpy = np.sort(_data_numpy).ravel()
    print("Time taken to sort the array: ", time.time() - start_time)

    if n is 0:
      start = time.time()
      num = _data_numpy.shape[0]
      lower_val = int(p * num)
      upper_val = num - lower_val

      if (lower_val > upper_val):
        raise ValueError("Proportion too big.")

      atmp = np.partition(_data_numpy, (lower_val, upper_val - 1), 0)
      sl = [slice(None)] * atmp.ndim
      sl[0] = slice(lower_val, upper_val)
      trim_mean = np.mean(atmp[tuple(sl)], axis=0)

      print("Time taken to calculate: ", time.time() - start)
      return trim_mean

    elif n is 1:
      start = time.time()
      trim_mean = stats.trim_mean(_data_numpy, p)
      print("Time taken to calculate: ", time.time() - start)
      return trim_mean
    
    if n is not 0 or n is not 1:
      print("Enter correct value")

  except StatisticsError as error:
    raise error
    
  except Exception as error:
    print(error)
    raise error
```

To use this function:

```
n = input("Enter 0 (To find trimmed mean without any library function), Enter 1 (Via using Library Function): ")
print("Data Type of taken input: ", type(n))

_emotion_type = input("Enter the type of emotion whose trimmed mean of pixel values you want to find: ")
print("Data Type of _emotion_type: ", type(_emotion_type))

p = input("Enter fraction of values you want to omit: ")
print("Data Type of taken value: ", type(p))

_data, _data_numpy, _data_label, _data_label_numpy = select_emotion(df_all, df_label, df, _emotion_type)
print(type(_data_numpy))

trim_mean = find_trimmed_mean(_data_numpy, n, p)
print("Trimmed Mean of sample: ", trim_mean)
```
